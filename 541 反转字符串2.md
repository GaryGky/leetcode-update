## 541 反转字符串2

**思路**：（**Easy**）

模拟字符串反转的过程，使用StringBuilder对字符串进行动态的变化，因为String是静态类，一旦创建无法修改，所以使用StringBuilder 进行封装。

```java
class Solution {
    public String reverseStr(String s, int k) {
        StringBuilder builder = new StringBuilder(s);
        int n = s.length();
        int start = 0;
        while(start < n){
            if(start + k >= n){
                reverse(builder, start, n-1);
                return builder.toString();
            }else if(start + 2*k >= n){
                reverse(builder, start, start+k-1);
                return builder.toString();
            }
            reverse(builder, start, start+k-1);
            start += 2*k;
        }
        return builder.toString();
    }
    private void reverse(StringBuilder b, int start, int end){
        while(start <= end){
            char tmp = b.charAt(start);
            b.setCharAt(start, b.charAt(end));
            b.setCharAt(end,tmp);
            start++;
            end--;
        }
    }
}
```

## 剑指Offer 58 左旋转字符串

为了使本题更有意义，要求不能使用额外的空间，只能使用`in-place`的方式进行旋转。

算法分为三个步骤：

- 旋转前n个字符串
- 反转n到末尾的字符串
- 反转整个字符串

性能：翻转的时间复杂度为：O(N) ，进行三次翻转是常数倍，所以算法上界仍然为`O(N)`

<img src='https://code-thinking.cdn.bcebos.com/pics/剑指Offer58-II.左旋转字符串.png' width=600> </img>

```java
class Solution {
    public String reverseLeftWords(String s, int n) {
        // O(N)的时间复杂度
        StringBuilder b = new StringBuilder(s);
        reverse(b, 0, n-1);
        reverse(b,n,s.length()-1);
        reverse(b,0,s.length()-1);
        return b.toString();
    }
    // O(n)
    private void reverse(StringBuilder b, int start, int end){
        while(start <= end){
            char tmp = b.charAt(start);
            b.setCharAt(start, b.charAt(end));
            b.setCharAt(end, tmp);
            start++;
            end--;
        }
    }
}
```

## 28 使用KMP算法计算needle是否匹配haystack串

**KMP算法两个关键点：**

- 计算**next**数组

  ```java
  // 1. 构造Next数组: next[i] 等于以i结尾的最长公共前后缀长度
  int[] next = new int[needle.length()];
  int j=-1;
  next[0]=j;
  for(int i=1;i<needle.length();i++){
      // 回退
      while(j>=0 && needle.charAt(j+1)!=needle.charAt(i)){
          j = next[j]; 
      }
      if(needle.charAt(j+1) == needle.charAt(i)){
          j++;
      }
      next[i] = j;
  }
  ```

- 根据**next**数组进行匹配

  ```java
  // 2. 根据Next数组计算是否存在相同的数组
  int index = 0;
  for(int i=0;i<haystack.length();i++){
      // 不匹配: 寻找之前匹配的位置 index回退
      while(index>0 && needle.charAt(index)!=haystack.charAt(i)){
          index = next[index-1];
      }
      // 匹配: needle index ++
      if(haystack.charAt(i) == needle.charAt(index)){
          index++;
          if(index == needle.length()){
              return i-index+1;
          }
      }
  }
  ```

  