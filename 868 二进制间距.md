## 868 二进制间距

给定一个正整数 n，找到并返回 n 的二进制表示中两个 相邻 1 之间的 最长距离 。如果不存在两个相邻的 1，返回 0 。如果只有 0 将两个 1 分隔开（可能不存在 0 ），则认为这两个 1 彼此 相邻 。两个 1 之间的距离是它们的二进制表示中位置的绝对差。例如，"1001" 中的两个 1 的距离为 3 。

### 思路

找到所有1的位置，然后依序比较相邻的1的距离，并且返回最大值。

```go
func binaryGap(n int) int {
    oneIndexes := make([]int, 0)
    index := 0
    N := n
    for N > 0{
        N = N >> 1
        index++
    }

    for n > 0 {
        digit := (n&1)
        if digit == 1{
            oneIndexes = append(oneIndexes, index)
        }
        n = n >> 1
        index--
    }

    ans := 0
    for i:=1;i<len(oneIndexes);i++{
        ans = max(ans, oneIndexes[i-1]-oneIndexes[i])
    }
    return ans
}
```

### 总结

> 这题可能涉及到计算机中：补码、反码的知识。**计算机中通常使用的是补码表示**。

- 原码：第一位是符号位，其余二进制位表示数字的真值；
- 反码：
  - 正数的反码是其本身（原码）；
  - 负数的反码是原码的符号位不变，其余各位取反。

- 补码：
  - 正数的补码就是其本身；
  - 负数的补码是在其原码的基础上，符号位不变，其余各位取反并加一。

#### 例子

正数的三种表示方法都是一样的结果

$[+1] = [00000001]原 = [00000001]反 = [00000001]补$

负数的表示方法则需要进行一定的计算

$[-1] = [10000001]原 = [11111110]反 = [11111111]补$

- 对于求int8范围$[-2^7, 2^7-1]$内的最大值，最小值

  ```
  const int8MAX = (^uint8(0) >> 1) // 0b01111111
  const int8MIN = int8MAX + 1 		 // 0b10000000
  ```

  